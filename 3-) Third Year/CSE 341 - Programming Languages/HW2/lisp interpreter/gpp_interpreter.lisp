(defvar *Keywords* (list "and" "or" "not" "equal" "less" "nil" "list" "append" "concat" "set"
                    "deffun" "defvar" "for" "if" "exit" "load" "disp" "true" "false"))

(defvar *KWs* (list "KW_AND" "KW_OR" "KW_NOT" "KW_EQUAL" "KW_LESS" "KW_NIL" "KW_LIST" "KW_APPEND" "KW_CONCAT" "KW_SET"
               "KW_DEFFUN" "KW_DEFVAR" "KW_FOR" "KW_IF" "KW_EXIT" "KW_LOAD" "KW_DISP" "KW_TRUE" "KW_FALSE"))

(defvar *Operators* (list "+" "-" "/" "*" "**" "(" ")" "\"" "\"" "," "'"))
(defvar *OPs* (list "OP_PLUS" "OP_MINUS" "OP_DIV" "OP_MULT" "OP_DBLMULT" "OP_OP" "OP_CP" "OP_OC" "OP_CC" "OP_COMMA" "CUT"))

(defvar *op_oc_count* 0)

(defvar *filename*)

(defvar *tokens* (list))
(defvar *tokensVal* (list))

(defvar *variables* (list))
(defvar *variablesVal* (list))

(defun isOP(op)
    (let ((index 0))
        (cond
            ((and (string= op "\"") (= 0 *op_oc_count*))
                (setf *op_oc_count* 1)
                (return-from isOP 7)
            )
            ((and (string= op "\"") (= 1 *op_oc_count*))
                (setf *op_oc_count* 0)
                (return-from isOP 8)
            )
            (t
                (loop for temp in *Operators*
                    do
                    (if (string= temp op)
                        (let()
                            (return-from isOP index)))
                    (setf index (+ 1 index))
                )
                -1
            )
        )
    )
 )

 (defun isValue(value)
	(let ((index 0) (ch) (dot_c 0) (temp_c_c))
	    (setf temp_c_c *op_oc_count*)
	    (setf ch (char value index))
	    (when (and (/= 1 (length value)) (string= ch "0"))
	        (setf ch (char value 1))
	        (cond
	            ((/= (isOP (string (char value 1))) -1)
	                (setf *op_oc_count* temp_c_c)
	                (return-from isValue 1))
	            ((> (length value) 2)
	                (setf index 2)
	            )
	            ((and (= (isOP (string (char value 1))) -1) (string/= ch "."))
	                (setf *op_oc_count* temp_c_c)
	                (return-from isValue 0))
	        )
	    )
		(loop
			do
			(setf ch (char value index))
			(cond
			    ((and (not(digit-char-p ch)) (= dot_c 0) (string= ch "."))
			        (setf dot_c 1))
			    ((and (not(digit-char-p ch)) (= dot_c 1) (string= ch "."))
			        (return-from isValue 0))
			    ((and (not(digit-char-p ch)) (= (isOP (string (char value index))) -1))
			        (return-from isValue 0))
			)
			(setq index (+ 1 index))

			(when (or (= index (length value)) (/= (isOP (string (char value index))) -1))
			    (setf dot_c 0)
			    (setf *op_oc_count* temp_c_c)
			    (return index))
		)
	    index
  	)
)

(defun isID(ID)
	(let ((index 0) (ch) (temp_c_c))
	    (setf temp_c_c *op_oc_count*)
	    (setf ch (char ID index))
	    (when (digit-char-p ch)
	        (return-from isID 0))
		(loop
			do
			(setf ch (char ID index))
			(if (not (or (alpha-char-p  ch) (digit-char-p ch) (char= #\_ ch) ))
                (return-from isID 0))
			(setq index (+ 1 index))

			(when (or (= index (length ID)) (/= (isOP (string (char ID index))) -1))
			    (setf *op_oc_count* temp_c_c)
			    (return index))
		)
	index
  	)
)

(defun isKeyWord(keyword)
	(let ((index 0) (ch) (word nil)(err 0) (kIndex 0) (temp_c_c))
	    (setf temp_c_c *op_oc_count*)
		(loop
			do
			(setf ch (char keyword index))
			(if (not(alpha-char-p  ch)) (setf err 1))
			(setf word ( concatenate 'string word (string ch)))
			(setq index (+ 1 index))
			(when (or (= index (length keyword)) (/= (isOP (string (char keyword index))) -1))
			    (setf *op_oc_count* temp_c_c)
			    (return index) )
		)
		(if (= err 1) (return-from isKeyWord (list -1 index)))
		(loop for temp in *Keywords*
	  		do
	  			(if (string= temp word)
	  				(return kIndex)
	  				(setf kIndex (+ 1 kIndex))
		  		)
		)
		(if (= kIndex (length *Keywords*)) (list -1 index) (list kIndex index))
  	)
)

(defun analyze_word (word ostream)
    (let ((subword nil) (index 0) (ch) (size) (lIndex) (rIndex) (opIndex 0))
    (setf size (length word))
        (loop while (/= index size)
            do
            (setf ch (string (char word index)))
            (setf subword (subseq word index))
            (cond
                ((/= (setq rIndex (isOP ch)) -1 )
                    (let ()
						(setf index (+ 1 index))
                        (setf opIndex index)
                        (if (string= (nth rIndex *Operators*) "*")
                            (progn
                                (if (= size index)
                                    (progn
                                        (setq *tokens* (append *tokens* (list (nth rIndex *OPs*))))
                                        (setq *tokensVal* (append *tokensVal* (list ch)))
                                        (return 1)))
                                (if (string= (string (char word index)) "*")
                                    (let ()
										(setf rIndex (+ 1 rIndex))
										(setf index (+ 1 index))
                                        (setf opIndex index)
									)
                                 )
                             )
                        )
                        (setq *tokens* (append *tokens* (list (nth rIndex *OPs*))))
                        (setq *tokensVal* (append *tokensVal* (list ch)))
                    )
                 )
                 ((/= (setq rIndex (isValue subword)) 0)
					(let ()
                        (setq *tokens* (append *tokens* (list "VALUE")))
                        (setf subword (remove #\) subword))
                        (setf subword (remove #\( subword))
                        (setf subword (remove #\+ subword))
                        (setf subword (remove #\- subword))
                        (setf subword (remove #\* subword))
                        (setf subword (remove #\/ subword))
                        (setf subword (remove #\" subword))
                        (setq *tokensVal* (append *tokensVal* (list subword)))
                        (setf index (+ index rIndex))
					)
				)
				((/= -1 (car (setq lIndex (isKeyWord subword))))
					(let ()
                        (setq *tokens* (append *tokens* (list (nth (car lIndex) *KWs*))))
                        (setq *tokensVal* (append *tokensVal* (list subword)))
						(setf index (+ index (cadr lIndex)))
					)

				)
				((/= (setq rIndex (isID subword)) 0)
					(let ()
                        (setq *tokens* (append *tokens* (list "IDENTIFIER")))
                        (setf subword (remove #\) subword))
                        (setf subword (remove #\( subword))
                        (setf subword (remove #\+ subword))
                        (setf subword (remove #\- subword))
                        (setf subword (remove #\* subword))
                        (setf subword (remove #\/ subword))
                        (setf subword (remove #\" subword))
                        (setq *tokensVal* (append *tokensVal* (list subword)))
                        (setf index (+ index rIndex))
					)
				)
                ( t
					(let (tempWord)
						(setf tempWord (subseq word opIndex size))
						(format t "~%SYNTAX_ERROR: ~A cannot be tokenized~c" tempWord #\NewLine)
                        (format ostream "~%SYNTAX_ERROR ~A cannot be tokenized~c" tempWord #\NewLine)
                        (return-from analyze_word -1)
					)
				)
            )
         )
     )
    1
)

(defun isVariable (token)
    (let ((index 0) (variablesSize (list-length *variables*)))
        (loop while (/= index variablesSize)
            do
            (when (equal (nth index *variables*) token)
                (return-from isVariable index)
            )
            (setf index (+ index 1))
        )
        -1
    )
)

(defun expb (tokens place)
    (let ((tokensSize (list-length tokens)))
        (cond
            ((and (> tokensSize 4) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP" )
                (or (string= (nth 1 tokens) "KW_AND" ) (string= (nth 1 tokens) "KW_OR" ) (string= (nth 1 tokens) "KW_EQUAL" ) (string= (nth 1 tokens) "KW_LESS" )))
                (cond
                    ((= tokensSize 5)
                        (let ((result))
                            (cond
                                ((string= (nth 1 tokens) "KW_AND")
                                    (return-from expb (logand (expb (list (nth 2 tokens)) (+ place 2)) (expb (list (nth 3 tokens)) (+ place 3)) )))
                                ((string= (nth 1 tokens) "KW_OR")
                                    (return-from expb (logior (expb (list (nth 2 tokens)) (+ place 2)) (expb (list (nth 3 tokens)) (+ place 3)) ) ))
                                ((string= (nth 1 tokens) "KW_EQUAL")
                                    (if (equal nil (equal (expb (list (nth 2 tokens)) (+ place 2)) (expb (list (nth 3 tokens)) (+ place 3)) ) )
                                        (setf result 0)
                                        (setf result 1)
                                    )
                                    (return-from expb result))
                                ((string= (nth 1 tokens) "KW_LESS")
                                    (if (equal nil (< (expb (list (nth 2 tokens)) (+ place 2)) (expb (list (nth 3 tokens)) (+ place 3)) ) )
                                        (setf result 0)
                                        (setf result 1)
                                    )
                                    (return-from expb result))
                            )
                        )
                    )
                    ((and (> tokensSize 5) )
                        (let ((list1) (list2) (index 2) (index2) (op_op_count 0) (op_cp_count 0) (value1) (returnVal) (value2))
                            (when (string= (nth 2 tokens) "OP_OP")
                                (setf op_op_count 1)
                                (loop while (/= op_op_count op_cp_count)
                                    do
                                    (when (= index (- tokensSize 1))
                                        (return-from expb -100))
                                    (setq list1 (append list1 (list (nth index tokens))))
                                    (setq index (+ index 1))
                                    (when (string= (nth index tokens) "OP_CP")
                                        (setf op_cp_count (+ op_cp_count 1)))
                                    (when (string= (nth index tokens) "OP_OP")
                                        (setf op_op_count (+ op_op_count 1)))
                                )
                            )
                            (setq list1 (append list1 (list (nth index tokens))))
                            (setq index (+ index 1))
                            (setq index2 index)
                            (when  (string= (nth index tokens) "OP_OP")
                                (setf op_op_count 1)
                                (setf op_cp_count 0)
                                (loop while (/= op_op_count op_cp_count)
                                    do
                                    (when (= index (- tokensSize 1))
                                        (return-from expb -100))
                                    (setq list2 (append list2 (list (nth index tokens))))
                                    (setq index (+ index 1))
                                    (when (string= (nth index tokens) "OP_CP")
                                        (setf op_cp_count (+ op_cp_count 1)))
                                    (when (string= (nth index tokens) "OP_OP")
                                        (setf op_op_count (+ op_op_count 1)))
                                )
                            )
                            (when (/= index (- tokensSize 2))
                                    (return-from expb -100))
                            (setq list2 (append list2 (list (nth index tokens))))
                            (setq index (+ index 1))
                            (setf value1 (expb list1 (+ place 2) ))
                            (setf value2 (expb list2 (+ place index2) ))
                            (cond
                                ((string= (nth 1 tokens) "KW_AND")
                                    (return-from expb (logand value1 value2)))
                                ((string= (nth 1 tokens) "KW_OR")
                                    (return-from expb (logior value1 value2)))
                                ((string= (nth 1 tokens) "KW_EQUAL")
                                    (if (equal nil (equal value1 value2))
                                        (setf returnVal 0)
                                        (setf returnVal 1)
                                    )
                                    (return-from expb returnVal))
                                ((string= (nth 1 tokens) "KW_LESS")
                                    (if (equal nil (< value1 value2))
                                        (setf returnVal 0)
                                        (setf returnVal 1)
                                    )
                                    (return-from expb returnVal))
                            )
                        )
                    )
                )
            )
            ((and (> tokensSize 3) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP") (string= (nth 1 tokens) "KW_NOT"))
                (let ((returnVal))
                    (cond
                        ((= tokensSize 4)
                            (setf returnVal (expb (list(nth (+ 2 place) tokens)) (+ 2 place)))
                            (cond
                                ((equal returnVal 0)
                                    (return-from expb 1)
                                )
                                ((equal returnval -100)
                                    (return-from expb -100)
                                )
                            )
                            (return-from expb 0)
                        )
                        ((and (> tokensSize 4) )
                            (let ((list1) (i 2) (op_op_count 0) (op_cp_count 0) (result))
                                (when (string= (nth 2 tokens) "OP_OP")
                                    (setf op_op_count 1)
                                    (loop while (/= op_op_count op_cp_count)
                                        do
                                        (when (= i (- tokensSize 1))
                                            (return-from expb -100))
                                        (setq list1 (append list1 (list (nth i tokens))))
                                        (setq i (+ i 1))
                                        (when (string= (nth i tokens) "OP_CP")
                                             (setf op_cp_count (+ op_cp_count 1)))
                                        (when (string= (nth i tokens) "OP_OP")
                                            (setf op_op_count (+ op_op_count 1)))
                                    )
                                )
                                (when (/= i (- tokensSize 2))
                                        (return-from expb -100))
                                (setq list1 (append list1 (list (nth i tokens))))
                                (setf result (expb list1 (+ place 2) ))
                                (setf returnVal result)
                                (cond
                                    ((equal returnVal 0)
                                        (return-from expb 1)
                                    )
                                    ((equal returnval -100)
                                        (return-from expb -100)
                                    )
                                )
                                (return-from expb 0)
                            )
                        )
                    )
                )
            )
            ((and (= tokensSize 1) (string= (nth 0 tokens) "KW_TRUE"))
                (return-from expb 1)
            )
            ((and (= tokensSize 1) (string= (nth 0 tokens) "KW_FALSE"))
                (return-from expb 0)
            )
            ((and (= tokensSize 1) (string= (nth 0 tokens) "VALUE"))
               (return-from expb (read-from-string (nth place *tokensVal*)))
            )
            ((and (= tokensSize 1) (string= (nth 0 tokens) "IDENTIFIER"))
                (let ((index) (result))
                    (setf index (isVariable (nth place *tokensVal*) ) )
                    (if (= index -1)
                        (progn
                            (print "The identifier has no value.")
                            (return-from expb -100)
                        )
                        (progn
                            (setf result (nth index *variablesVal*))
                            (return-from expb result)
                        )
                    )
                )
            )
        )

     -100
    )
)

(defun listVal (tokens place)
    (let ((tokensSize (list-length tokens)) (resultList nil) (tempList nil))
        (cond
            ((and (= tokensSize 3)(string= (nth 0 tokens) "CUT")(string= (nth 1 tokens) "OP_OP")(string= (nth 2 tokens) "OP_CP"))
                (setq resultList (append resultList (list "" )))
                (return-from listVal resultList)
            )
            ((or (and (> tokensSize 3)(string= (nth 0 tokens) "CUT")(string= (nth 1 tokens) "OP_OP")(string= (nth (- tokensSize 1) tokens) "OP_CP"))
                (and (> tokensSize 3)(string= (nth 0 tokens) "OP_OP")(string= (nth 1 tokens) "KW_LIST")(string= (nth (- tokensSize 1) tokens) "OP_CP")))
                (cond
                    ((= tokensSize 4)
                        (setq tempList(append tempList (list(expb (list(nth 2 tokens)) (+ 2 place) )) ))
                        (when (equal (nth 0 tempList) -100)
                            (return-from listVal nil))
                        (setq resultList tempList)
                        (return-from listVal resultList)
                    )
                    ((> tokensSize 4)
                        (let ((index 2))
                            (loop while (not (equal (nth index tokens) "OP_CP"))
                                do
                                (when (= index (- tokensSize 1))
                                    (return-from listVal nil))
                                (setq tempList(append tempList (list(expb (list(nth index tokens)) (+ index place) )) ))
                                (when (= (nth (- index 2) tempList) -100)
                                    (return-from listVal nil))
                                (setq resultList tempList)
                                (setq index (+ index 1))
                            )
                            (when (/= index (- tokensSize 1))
                                (return-from listVal nil))
                            (return-from listVal resultList)
                        )
                    )
                )
            )
        )
        nil
    )
)

(defun expilisti (tokens place)
    (let ( (tokensSize (list-length tokens)) (resultList) (tempList1) (tempList2))
        (cond
            ((and (> tokensSize 4)(string= (nth 0 tokens) "OP_OP")(string= (nth 1 tokens) "KW_CONCAT")(string= (nth (- tokensSize 1) tokens) "OP_CP"))
                (let ((index 2) (index2))
                    (loop while (not (equal (nth index tokens) "OP_CP"))
                        do
                        (when (= index (- tokensSize 1))
                            (return-from expilisti nil))
                        (setq tempList1 (append tempList1 (list (nth index tokens))))
                        (setq index (+ index 1))
                    )
                    (setq tempList1 (append tempList1 (list (nth index tokens))))
                    (setq index (+ index 1))
                    (setq index2 index)
                    (loop while (not (equal (nth index tokens) "OP_CP"))
                        do
                        (when (= index (- tokensSize 1))
                            (return-from expilisti nil))
                        (setq tempList2 (append tempList2 (list (nth index tokens))))
                        (setq index (+ index 1))
                    )
                    (when (/= index (- tokensSize 2))
                        (return-from expilisti nil))
                    (setq tempList2 (append tempList2 (list (nth index tokens))))
                    (setq index (+ index 1))
                    (setq tempList1 (listVal tempList1 (+ 2 place) ))
                    (when (equal tempList1 nil)
                        (return-from expilisti nil))
                    (setq tempList2 (listVal tempList2 (+ index2 place) ))
                    (when (equal tempList2 nil)
                        (return-from expilisti nil))
                    (setq resultList (append tempList1 tempList2))
                    (return-from expilisti resultList)
                )
            )
            ((and (> tokensSize 4)(string= (nth 0 tokens) "OP_OP")(string= (nth 1 tokens) "KW_APPEND")(string= (nth (- tokensSize 1) tokens) "OP_CP"))
                (let ((index 2) (index2) (op_op_count 0) (op_cp_count 0))
                    (when (string= (nth 2 tokens) "OP_OP")
                        (setf op_op_count 1)
                        (loop while (/= op_op_count op_cp_count)
                            do
                            (when (= index (- tokensSize 1))
                                (return-from expilisti nil))
                            (setq tempList1 (append tempList1 (list (nth index tokens))))
                            (setq index (+ index 1))
                            (when (string= (nth index tokens) "OP_CP")
                                (setf op_cp_count (+ op_cp_count 1)))
                            (when (string= (nth index tokens) "OP_OP")
                                (setf op_op_count (+ op_op_count 1)))
                        )
                    )
                    (setq tempList1 (append tempList1 (list (nth index tokens))))
                    (setq index (+ index 1))
                    (setq index2 index)
                    (loop while (not (equal (nth index tokens) "OP_CP"))
                        do
                        (when (= index (- tokensSize 1))
                            (return-from expilisti nil))
                        (setq tempList2 (append tempList2 (list (nth index tokens))))
                        (setq index (+ index 1))
                    )
                    (when (/= index (- tokensSize 2))
                        (return-from expilisti nil))
                    (setq tempList2 (append tempList2 (list (nth index tokens))))
                    (setq index (+ index 1))
                    (setq tempList1 (list (expi tempList1 (+ 2 place) )))
                    (when (equal tempList1 nil)
                        (return-from expilisti nil))
                    (setq tempList2 (listVal tempList2 (+ index2 place) ))
                    (when (equal tempList2 nil)
                        (return-from expilisti nil))
                    (setq resultList (append tempList1 tempList2))
                    (return-from expilisti resultList)
                )
            )
            ((and (> tokensSize 3) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP" )(string= (nth 1 tokens) "KW_DISP"))
                (let ((result) (list1) (i 2) (op_op_count 0) (op_cp_count 0))
                    (when (string= (nth 2 tokens) "OP_OP")
                        (setf op_op_count 1)
                        (setf op_cp_count 0)
                        (loop while (/= op_op_count op_cp_count)
                            do
                            (when (= i (- tokensSize 1))
                                (return-from expilisti nil))
                            (setq list1 (append list1 (list (nth i tokens))))
                            (setq i (+ i 1))
                            (when (string= (nth i tokens) "OP_CP")
                                (setf op_cp_count (+ op_cp_count 1)))
                            (when (string= (nth i tokens) "OP_OP")
                                (setf op_op_count (+ op_op_count 1)))
                        )
                    )
                    (when (/= i (- tokensSize 2))
                            (return-from expilisti nil))
                    (setq list1 (append list1 (list (nth i tokens))))
                    (setq i (+ i 1))
                    (setf result (expilisti list1 (+ place 2) ))
                    (return-from expilisti result)
                )
            )
            ((and (> tokensSize 4) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP" )(string= (nth 1 tokens) "KW_IF"))
                (let ((result) (boolean) (list1) (list2) (i 2) (index2) (index3) (op_op_count 0) (op_cp_count 0))
                    (when (string= (nth 2 tokens) "OP_OP")
                        (setf op_op_count 1)
                        (setf op_cp_count 0)
                        (loop while (/= op_op_count op_cp_count)
                            do
                            (when (= i (- tokensSize 1))
                                (return-from expilisti nil))
                            (setq boolean (append boolean (list (nth i tokens))))
                            (setq i (+ i 1))
                            (when (string= (nth i tokens) "OP_CP")
                                (setf op_cp_count (+ op_cp_count 1)))
                            (when (string= (nth i tokens) "OP_OP")
                                (setf op_op_count (+ op_op_count 1)))
                        )
                    )
                    (setq boolean (append boolean (list (nth i tokens))))
                    (setf i (+ 1 i))
                    (setq index2 i)
                        (when (string= (nth i tokens) "OP_OP")
                            (setf op_op_count 1)
                            (setf op_cp_count 0)
                            (loop while (/= op_op_count op_cp_count)
                                do
                                (when (= i (- tokensSize 1))
                                    (return-from expilisti nil))
                                (setq list1 (append list1 (list (nth i tokens))))
                                (setq i (+ i 1))
                                (when (string= (nth i tokens) "OP_CP")
                                    (setf op_cp_count (+ op_cp_count 1)))
                                (when (string= (nth i tokens) "OP_OP")
                                    (setf op_op_count (+ op_op_count 1)))
                            )
                        )
                        (setq list1 (append list1 (list (nth i tokens))))
                        (setq i (+ i 1))
                        (cond
                            ((and (= i (- tokensSize 1)) (= (expb boolean (+ place 2) )1 ))
                                (return-from expilisti (expilisti list1 (+ place index2)) ))
                            ((and (= i (- tokensSize 1)) (= (expb boolean (+ place 2) )0 ))
                                (return-from expilisti '(".")))
                        )
                        (setq index3 i)
                        (when (string= (nth i tokens) "OP_OP")
                            (setf op_op_count 1)
                            (setf op_cp_count 0)
                            (loop while (/= op_op_count op_cp_count)
                                do
                                (when (= i (- tokensSize 1))
                                    (return-from expilisti nil))
                                (setq list2 (append list2 (list (nth i tokens))))
                                (setq i (+ i 1))
                                (when (string= (nth i tokens) "OP_CP")
                                    (setf op_cp_count (+ op_cp_count 1)))
                                (when (string= (nth i tokens) "OP_OP")
                                    (setf op_op_count (+ op_op_count 1)))
                            )
                        )
                        (setq list2 (append list2 (list (nth i tokens))))
                        (setq i (+ i 1))
                        (when (/= i (- tokensSize 1))
                            (return-from expilisti nil))
                        (if (= (expb boolean (+ place 2) ) 1 )
                            (return-from expilisti (expilisti list1 (+ place index2)) )
                            (return-from expilisti (expilisti list2 (+ place index3)) )
                        )
                )
            )
            ((not (equal nil (listVal tokens place)))
                (return-from expilisti (listVal tokens place))
            )
        )
    )
)

(defun expi (tokens place)
    (let ((tokensSize (list-length tokens)))
        (cond
            ((and (> tokensSize 4) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP" )
                (or (string= (nth 1 tokens) "OP_PLUS") (string= (nth 1 tokens) "OP_MINUS") (string= (nth 1 tokens) "OP_DIV")(string= (nth 1 tokens) "OP_MULT") (string= (nth 1 tokens) "OP_DBLMULT")))
                (let ((value1 0)(value2 0)(result 1))
                    (cond
                        ((= tokensSize 5)
                            (setf value1 (expi (list (nth 2 tokens)) (+ place 2) ))
                            (setf value2 (expi (list (nth 3 tokens)) (+ place 3) ))
                            (cond
                                ((and (/= value1 -100) (/= value2 -100) (string= (nth 1 tokens) "OP_PLUS"))
                                    (return-from expi (+ value1 value2)))
                                ((and (/= value1 -100) (/= value2 -100) (string= (nth 1 tokens) "OP_MINUS"))
                                    (return-from expi (- value1 value2)))
                                ((and (/= value1 -100) (/= value2 -100) (/= value2 0) (string= (nth 1 tokens) "OP_DIV"))
                                    (return-from expi (/ value1 value2)))
                                ((and (/= value1 -100) (/= value2 -100) (string= (nth 1 tokens) "OP_MULT"))
                                    (return-from expi (* value1 value2)))
                                ((and (/= value1 -100) (/= value2 -100) (string= (nth 1 tokens) "OP_DBLMULT"))
                                    (dotimes (n value2)
                                        (setq result (* result value1)))
                                    (return-from expi result))
                            )
                        )
                        ((and (> tokensSize 5))
                            (let ((list1) (list2) (index 2) (index2) (result) (op_op_count 0) (op_cp_count 0))
                                (when (string= (nth 2 tokens) "OP_OP")
                                    (setf op_op_count 1)
                                    (loop while (/= op_op_count op_cp_count)
                                        do
                                        (when (= index (- tokensSize 1))
                                            (return-from expi -100))
                                        (setq list1 (append list1 (list (nth index tokens))))
                                        (setq index (+ index 1))
                                        (when (string= (nth index tokens) "OP_CP")
                                            (setf op_cp_count (+ op_cp_count 1)))
                                        (when (string= (nth index tokens) "OP_OP")
                                            (setf op_op_count (+ op_op_count 1)))
                                    )
                                )
                                (setq list1 (append list1 (list (nth index tokens))))
                                (setq index (+ index 1))
                                (setq index2 index)
                                (when  (string= (nth index tokens) "OP_OP")
                                    (setf op_op_count 1)
                                    (setf op_cp_count 0)
                                    (loop while (/= op_op_count op_cp_count)
                                        do
                                        (when (= index (- tokensSize 1))
                                            (return-from expi -100))
                                        (setq list2 (append list2 (list (nth index tokens))))
                                        (setq index (+ index 1))
                                        (when (string= (nth index tokens) "OP_CP")
                                            (setf op_cp_count (+ op_cp_count 1)))
                                        (when (string= (nth index tokens) "OP_OP")
                                            (setf op_op_count (+ op_op_count 1)))
                                    )
                                )
                                (when (/= index (- tokensSize 2))
                                        (return-from expi -100))
                                (setq list2 (append list2 (list (nth index tokens))))
                                (setq index (+ index 1))
                                (setf value1 (expi list1 (+ place 2) ))
                                (setf value2 (expi list2 (+ place index2) ))
                                (cond
                                    ((and (/= value1 -100) (/= value2 -100) (string= (nth 1 tokens) "OP_PLUS"))
                                        (return-from expi (+ value1 value2)))
                                    ((and (/= value1 -100) (/= value2 -100) (string= (nth 1 tokens) "OP_MINUS"))
                                        (return-from expi (- value1 value2)))
                                    ((and (/= value1 -100) (/= value2 -100) (/= value2 0) (string= (nth 1 tokens) "OP_DIV"))
                                        (return-from expi (/ value1 value2)))
                                    ((and (/= value1 -100) (/= value2 -100) (string= (nth 1 tokens) "OP_MULT"))
                                        (return-from expi (* value1 value2)))
                                    ((and (/= value1 -100) (/= value2 -100) (string= (nth 1 tokens) "OP_DBLMULT"))
                                        (dotimes (n value2)
                                            (setq result (* result value1)))
                                        (return-from expi result))
                                )
                            )
                        )
                    )
                )
            )
            ((and (> tokensSize 4) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP" )(string= (nth 1 tokens) "KW_DEFVAR") (string= (nth 2 tokens) "IDENTIFIER"))
                (let ( (variablesSize (list-length *variables*)) (index) (result))
                    (setf index (isVariable (nth (+ place 2) *tokensVal*) ))
                    (if (= index -1)
                        (progn
                            (setq *variables* (append *variables* (list (nth (+ place 2) *tokensVal*))))
                            (cond
                                ((= tokensSize 5)
                                    (setf result (expi (list (nth 3 tokens)) (+ place 3) ) )
                                    (setq *variablesVal* (append *variablesVal* (list result)))
                                    (return-from expi result)
                                )
                                ((and (> tokensSize 5))
                                    (let ((list1) (i 3) (op_op_count 0) (op_cp_count 0))
                                        (when (string= (nth 3 tokens) "OP_OP")
                                            (setf op_op_count 1)
                                            (setf op_cp_count 0)
                                            (loop while (/= op_op_count op_cp_count)
                                                do
                                                (when (= i (- tokensSize 1))
                                                    (return-from expi -100))
                                                (setq list1 (append list1 (list (nth i tokens))))
                                                (setq i (+ i 1))
                                                (when (string= (nth i tokens) "OP_CP")
                                                    (setf op_cp_count (+ op_cp_count 1)))
                                                (when (string= (nth i tokens) "OP_OP")
                                                    (setf op_op_count (+ op_op_count 1)))
                                            )
                                        )
                                        (when (/= i (- tokensSize 2))
                                                (return-from expi -100))
                                        (setq list1 (append list1 (list (nth i tokens))))
                                        (setq i (+ i 1))
                                        (setf result (expi list1 (+ place 3) ))
                                        (setq *variablesVal* (append *variablesVal* (list result)))
                                        (return-from expi result)
                                    )
                                )
                            )
                        )
                        (progn
                            (print "This identifier is already defined.")
                            (return-from expi -100))
                    )
                )
            )
            ((and (> tokensSize 4) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP" )(string= (nth 1 tokens) "KW_SET") (string= (nth 2 tokens) "IDENTIFIER"))
                (let ( (variablesSize (list-length *variables*)) (index) (result))
                    (setf index (isVariable (nth (+ place 2) *tokensVal*) ))
                    (if (= index -1)
                        (progn
                            (print "The identifier is not defined before to set a value.")
                            (return-from expi -100))
                        (progn
                            (cond
                                ((= tokensSize 5)
                                    (setf result (expi (list (nth 3 tokens)) (+ place 3) ) )
                                    (setf (nth index *variablesVal*) result)
                                    (return-from expi result)
                                )
                                ((and (> tokensSize 5))
                                    (let ((list1) (i 3) (op_op_count 0) (op_cp_count 0))
                                        (when (string= (nth 3 tokens) "OP_OP")
                                            (setf op_op_count 1)
                                            (setf op_cp_count 0)
                                            (loop while (/= op_op_count op_cp_count)
                                                do
                                                (when (= i (- tokensSize 1))
                                                    (return-from expi -100))
                                                (setq list1 (append list1 (list (nth i tokens))))
                                                (setq i (+ i 1))
                                                (when (string= (nth i tokens) "OP_CP")
                                                    (setf op_cp_count (+ op_cp_count 1)))
                                                (when (string= (nth i tokens) "OP_OP")
                                                    (setf op_op_count (+ op_op_count 1)))
                                            )
                                        )
                                        (when (/= i (- tokensSize 2))
                                                (return-from expi -100))
                                        (setq list1 (append list1 (list (nth i tokens))))
                                        (setq i (+ i 1))
                                        (setf result (expi list1 (+ place 3) ))
                                        (setf (nth index *variablesVal*) result)
                                        (return-from expi result)
                                    )
                                )
                            )
                        )
                    )
                )
            )
            ((and (> tokensSize 3) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP" )(string= (nth 1 tokens) "KW_DISP"))
                (let ((result))
                    (cond
                        ((= tokensSize 4)
                            (setf result (expi (list (nth 2 tokens)) (+ place 2)))
                            (return-from expi result)
                        )
                        ((and (> tokensSize 4))
                            (let ((list1) (i 2) (result) (op_op_count 0) (op_cp_count 0))
                                (when (string= (nth 2 tokens) "OP_OP")
                                    (setf op_op_count 1)
                                    (setf op_cp_count 0)
                                    (loop while (/= op_op_count op_cp_count)
                                        do
                                        (when (= i (- tokensSize 1))
                                            (return-from expi -100))
                                        (setq list1 (append list1 (list (nth i tokens))))
                                        (setq i (+ i 1))
                                        (when (string= (nth i tokens) "OP_CP")
                                            (setf op_cp_count (+ op_cp_count 1)))
                                        (when (string= (nth i tokens) "OP_OP")
                                            (setf op_op_count (+ op_op_count 1)))
                                    )
                                )
                                (when (/= i (- tokensSize 2))
                                        (return-from expi -100))
                                (setq list1 (append list1 (list (nth i tokens))))
                                (setq i (+ i 1))
                                (setf result (expi list1 (+ place 2) ))
                                (return-from expi result)
                            )
                        )
                    )
                )
            )
            ((and (> tokensSize 4) (string= (nth 0 tokens) "OP_OP") (string= (nth (- tokensSize 1) tokens) "OP_CP" )(string= (nth 1 tokens) "KW_IF"))
                (let ((result) (boolean) (list1) (list2) (i 2) (index2) (index3) (op_op_count 0) (op_cp_count 0))
                    (when (string= (nth 2 tokens) "OP_OP")
                        (setf op_op_count 1)
                        (setf op_cp_count 0)
                        (loop while (/= op_op_count op_cp_count)
                            do
                            (when (= i (- tokensSize 1))
                                (return-from expi -100))
                            (setq boolean (append boolean (list (nth i tokens))))
                            (setq i (+ i 1))
                            (when (string= (nth i tokens) "OP_CP")
                                (setf op_cp_count (+ op_cp_count 1)))
                            (when (string= (nth i tokens) "OP_OP")
                                (setf op_op_count (+ op_op_count 1)))
                        )
                    )
                    (setq boolean (append boolean (list (nth i tokens))))
                    (setf i (+ 1 i))
                    (setq index2 i)
                        (when (string= (nth i tokens) "OP_OP")
                            (setf op_op_count 1)
                            (setf op_cp_count 0)
                            (loop while (/= op_op_count op_cp_count)
                                do
                                (when (= i (- tokensSize 1))
                                    (return-from expi -100))
                                (setq list1 (append list1 (list (nth i tokens))))
                                (setq i (+ i 1))
                                (when (string= (nth i tokens) "OP_CP")
                                    (setf op_cp_count (+ op_cp_count 1)))
                                (when (string= (nth i tokens) "OP_OP")
                                    (setf op_op_count (+ op_op_count 1)))
                            )
                        )
                        (setq list1 (append list1 (list (nth i tokens))))
                        (setq i (+ i 1))
                        (cond
                            ((and (= i (- tokensSize 1)) (= (expb boolean (+ place 2) )1 ))
                                (return-from expi (expi list1 (+ place index2)) ))
                            ((and (= i (- tokensSize 1)) (= (expb boolean (+ place 2) )0 ))
                                (return-from expi -101))
                        )
                        (setq index3 i)
                        (when (string= (nth i tokens) "OP_OP")
                            (setf op_op_count 1)
                            (setf op_cp_count 0)
                            (loop while (/= op_op_count op_cp_count)
                                do
                                (when (= i (- tokensSize 1))
                                    (return-from expi -100))
                                (setq list2 (append list2 (list (nth i tokens))))
                                (setq i (+ i 1))
                                (when (string= (nth i tokens) "OP_CP")
                                    (setf op_cp_count (+ op_cp_count 1)))
                                (when (string= (nth i tokens) "OP_OP")
                                    (setf op_op_count (+ op_op_count 1)))
                            )
                        )
                        (setq list2 (append list2 (list (nth i tokens))))
                        (setq i (+ i 1))
                        (when (/= i (- tokensSize 1))
                            (return-from expi -100))
                        (if (= (expb boolean (+ place 2) ) 1 )
                            (return-from expi (expi list1 (+ place index2)) )
                            (return-from expi (expi list2 (+ place index3)) )
                        )
                )
            )
            ((and (= tokensSize 3) (string= (nth 0 tokens) "OP_OP") (string= (nth 1 tokens) "KW_EXIT") (string= (nth (- tokensSize 1) tokens) "OP_CP" )
                (print "SYTNAX OK!")
                (print "Interpreter exits.")
                (return-from expi -102))
            )
            ((/= -100 (expb tokens place))
                (return-from expi (expb tokens place))
            )
        )


    -100
    )


)

;;Takes a line of strings as parameter. Separates the strings in the line and stores in word_list
;;The loop runs till the index=length of the line
;;In the loop condition checks each character if it is a space or tab. If it is not the character is concatenated to word
;;If a space or tab is found word is stored in word_list and then emptied.
;;When the loop ends there might still be a word left in the word. If word is not null it is added to word_list
;;word_list is reversed and returned
(defun split_line (line)
  (let ((word nil) (index 0) (ch) (word_list (list)))
  	(loop
  		(setf ch (string (char line index)))
		(cond
			((or (string= ch #\Space) (string= ch #\Tab) (string= ch #\return) (string= ch #\linefeed) (string= ch ""))
                (if (not (eql word nil))
                    (progn
                        (setf word_list (cons word word_list))
                        (setf word nil)
                    )
                )
            )
			( t
                (setf word ( concatenate 'string word ch )))
		)
		(setf index (+ index 1))
		(when (= (length line) index)
            (return word_list))
	)
	(if (not (eql word nil))
        (setf word_list (cons word word_list)) )
	(reverse word_list)
  )
)

;;Takes a line to analyze the words
;;Checks if the line is a comment first. If it is, prints COMMENT then directly returns 1 meaning line is analyzed properly.
;;If it is not a comments, the line is separated into words and stored in word_list
;;For each word in the word_list analyze_word function is called to tokenize it and then print the token
;;If the word can be tokenized returns 1. Returns 0 for exit and returns -1 for UNKNWON
(defun analyze_line (line ostream)
	(let ((word_list nil)(check 0) (result) (listResult))
	    (setf *tokens* (list))
	    (setf *tokensVal* (list))
        (when (and (> (length line) 1) (char= (char line 0) #\;) (char= (char line 1) #\;))
            (progn
                (setq *tokens* (append *tokens* (list "COMMENT")))
                (setq *tokensVal* (append *tokensVal* (list line)))
                (return-from analyze_line 1)
            )
         )
        (when (< (length line) 1)
            (return-from analyze_line 1))
		(setf word_list (split_line line))
		(loop for temp in word_list
	  		do
            (setq check(analyze_word temp ostream))
            (when (= check -1)
                (return-from analyze_line -1))
        )
        (setf result (expi *tokens* 0))
        (setf listResult (expilisti *tokens* 0))
        (cond
            ((= result -102)
                (return-from analyze_line -2)
            )
            ((= result -101)
                (print "SYTNAX OK!"))
            ((/= result -100)
                (print "SYTNAX OK!")
                (print result)
            )
            ((equal listResult '("."))
                (print "SYTNAX OK!"))
            ((not(equal listResult nil))
                (print "SYTNAX OK!")
                (print listResult)
            )
            ((and (= result -100) (equal listResult nil) )
                (print "ERROR: EXPRESSION NOT RECOGNIZED.")
            )
        )
    )
   1
)

;;gppinterpreter is a function which takes 0 or 1 parameters.
;;parameter must be a file name
;;if no parameter is given, input from user is taken and the input is evaluated line by line
;;/if filename is given as parameter, input is taken from a file and it is evaluated line by line till the end of the file.
(defun gppinterpreter (&optional (filename -1))
	(if (equal filename -1)
		(let ((line) (line_check))
            (with-open-file (ostream "output.txt" :direction :output :if-exists :supersede :if-does-not-exist :create)
                (loop
                   (format t ">")
                   (setq line (read-line))
                   (setq line_check (analyze_line line ostream))
                   (terpri)
                   (when (= line_check -1)
                        (print "Lexer closing due to an error.")
                        (return))
                    (when (= line_check -2)
                        (return))
                )
             )
		)
		(let ((input_file (open filename :if-does-not-exist nil)) (line_check))
            (with-open-file (ostream "output.txt" :direction :output :if-exists :supersede :if-does-not-exist :create)
                (when input_file
                    (loop for line = (read-line input_file nil)
                        while line do
                            (setq line_check (analyze_line line ostream))
                            (when (= line_check -2)
                                (return))
                            (terpri)
                            (format ostream "~%"))
                    (close input_file)
                    (print "End of file. Lexer is closing.")
                )
             )
		)
	)
)

(defun find_format ()
	(format t "If you wanna read from a file enter filename. Else enter start. ~%")
    (format t "g++ ")
    (let ((rline) (format_result))
        (setq rline (read-line))
        (terpri)
        (if (string= rline "start")
            (setq format_result 0)
            (progn
                (setq format_result 1)
                (setq *filename* rline)
             )
        )
        (return-from find_format format_result)
    )
)

(defvar *format_input* (find_format))
(if (= *format_input* 0)
    (gppinterpreter))
(if (= *format_input* 1)
    (gppinterpreter *filename*))
